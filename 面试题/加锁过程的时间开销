关于CPU，有3个重要的概念：上下文切换（context switchs），运行队列（Run queue）和使用率（utilization）。

上下文切换：
　　 目前流行的CPU在同一时间内只能运行一个线程，超线程的处理器可以在同一时间运行多个线程（包括多核CPU），Linux内核会把多核的处理器当作多个单独的CPU来识别。
　 　一个标准的Linux内核可以支持运行50～50000个进程运行，对于普通的CPU，内核会调度和执行这些进程。每个进程都会分到CPU的时间片来运 行，当一个进程用完时间片或者被更高优先级的进程抢占后，它会备份到CPU的运行队列中，同时其他进程在CPU上运行。这个进程切换的过程被称作上下文切 换。过多的上下文切换会造成系统很大的开销。

运行队列
　　每个CPU都会维持一个运行队列，理想情况下，调度器会不断让队列中的进程运行。进程不是处在sleep状态就是run able状态。如果CPU过载，就会出现调度器跟不上系统的要求，导致可运行的进程会填满队列。队列愈大，程序执行时间就愈长。

一、互斥锁的开销主要在内核态与用户态的切换：

  申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切换）；没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换）；被唤醒进程在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内核态的切换。同时，其他竞争锁的进程在这个过程中也要进行一次切换。

  进程上下文切换的直接消耗包括CPU寄存器保存和加载，需要调度时有内核调度代码的执行。



二、自旋锁：

  与互斥锁不同的是自旋锁不会引起调用者睡眠。如果自旋锁已经被别的进程保持，调用者就轮询（不断的消耗CPU的时间）是否该自旋锁的保持者已经释放了锁（"自旋"一词就是因此而得名）。