ConcurrentHashMap1.8中是基于什么机制来保证线程安全性的
1.取消了segment分段设计，直接使用node数据来保存数据，并且采用node数组的元素作为锁来实现每一行数据
进行加锁来进一步减少并发冲突的概率
2.将原本1.7的数组+单向链表的数据结构更新为数据+单向链表和红黑树的结构。


ConcurrentHashMap通过get方法获取数据的时候，是否需要通过加锁来保证数据的可见性？为什么？
不需要，因为val和next是volatile修饰，而被volatile修饰的话,写操作对读操作是可见的



ConcurrentHashMap1.7和ConcurrentHashMap1.8有哪些区别？
1.将原本1.7的数组+单向链表的数据结构更新为数据+单向链表和红黑树的结构。
2.取消了segment分段的设计，直接采用node数组来保存数据，在并发的情况下，
采取数组相同下标位置元素的head为锁，使锁的力度更小更细，能更好的控制锁的力度
3.在计算size时，引入了分段的思想，通过算法把累加的长度存储到数组的元素上，最后遍历数组元素相加，能
能加快size的计算速度。



ConcurrentHashMap1.8为什么要引入红黑树？
在正常情况下，key hash 之后如果能够很均匀的分散在数组中，那么table 数
组中的每个队列的长度主要为0 或者1.但是实际情况下，还是会存在一些队列长度过长的
情况。如果还采用单向列表方式，那么查询某个节点的时间复杂度就变为O(n); 因此对于
队列长度超过8 的列表，JDK1.8 采用了红黑树的结构，那么查询的时间复杂度就会降低到
O(logN),可以提升查找的性能；